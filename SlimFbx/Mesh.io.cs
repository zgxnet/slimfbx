using Stride.Core.Mathematics;
using System.Text;
namespace SlimFbx;

partial class Mesh
{
    public struct MeshSaveOptions
    {
        public Vector3[]? NewPositions;
        public bool IncludeNormals;
        //public bool IncludeUVs;
    }

    public void SaveAsObj(string filePath, MeshSaveOptions options = default)
    {
        using var writer = new StreamWriter(filePath);

        if (!IsTriangleMesh && Polygons == null)
            throw new InvalidOperationException("Polygons data is null for non-triangle mesh.");

        // Write header comment
        writer.WriteLine("# OBJ file generated by SlimFbx");
        writer.WriteLine($"# Vertices: {VertexPositions.Length}");
        writer.WriteLine($"# Faces: {(IsTriangleMesh ? Indices.Length / 3 : Polygons!.Length)}");
        writer.WriteLine();

        // Write vertices (apply transform if provided)
        for (int i = 0; i < VertexCount; i++)
        {
            var v = options.NewPositions != null ? options.NewPositions[i] : VertexPositions[i];
            writer.WriteLine($"v {v.X} {v.Y} {v.Z}");
        }

        // Write vertex normals if available
        bool saveNormals = options.IncludeNormals && VertexNormals != null;
        if (saveNormals)
        {
            writer.WriteLine();
            foreach (var normal in VertexNormals!)
            {
                writer.WriteLine($"vn {normal.X} {normal.Y} {normal.Z}");
            }
        }

        writer.WriteLine();

        // Write faces
        StringBuilder faceIndices = new();
        if (IsTriangleMesh)
        {
            // For triangle mesh, process indices in groups of 3
            for (int i = 0; i < Indices.Length; i += 3)
            {
                faceIndices.Clear();
                faceIndices.Append('f');
                for (int j = 0; j < 3; j++)
                {
                    int v = Indices[i + j] + 1;
                    faceIndices.Append($" {v}");
                    if (saveNormals)
                        faceIndices.Append($"//{v}");
                }
                writer.WriteLine(faceIndices);
            }
        }
        else
        {
            // For polygon mesh, use polygon definitions
            foreach (var polygon in Polygons!)
            {
                if (polygon.Size < 3) continue; // Skip invalid polygons
                faceIndices.Clear();
                faceIndices.Append('f');
                for (int i = 0; i < polygon.Size; i++)
                {
                    int vertexIndex = Indices[polygon.Index + i] + 1; // OBJ uses 1-based indexing
                    faceIndices.Append($" {vertexIndex}");
                    if (saveNormals)
                        faceIndices.Append($"//{vertexIndex}");
                }               
                writer.WriteLine(faceIndices);
            }
        }
    }
}
